// HennovelTranslations plugin for LNReader
// Template JS plugin for LNReader (lnreader-plugins format).
// Notes:
// - This is a best-effort implementation based on typical WordPress/fictioneer sites.
// - If chapters or content don't parse, open a sample novel URL and paste it here; I'll adapt selectors.
// - Primary domains tried: hennoveltranslations.com and hennoveltranslations.org

const BASE_DOMAINS = [
  'https://hennoveltranslations.com',
  'https://hennoveltranslations.org',
];

const PLUGIN = {
  id: 'hennoveltranslations',
  name: 'HennovelTranslations',
  version: '1.0.0',
  author: 'Generated by assistant',
  website: 'https://hennoveltranslations.com',
  language: 'english',
  icon: 'https://hennoveltranslations.com/favicon.ico',
  description: 'Source plugin for HennovelTranslations (hennoveltranslations.com / .org).',
  // core methods used by LNReader's plugin runner
  async fetchText(url, opts = {}) {
    const res = await fetch(url, opts);
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText} when fetching ${url}`);
    return await res.text();
  },

  // helper: choose first working base domain
  async resolveBase() {
    for (const d of BASE_DOMAINS) {
      try {
        const resp = await fetch(d, { method: 'HEAD' });
        if (resp.ok) return d;
      } catch (e) {
        // ignore and try next
      }
    }
    // fallback to primary
    return BASE_DOMAINS[0];
  },

  // parse HTML and return a DOMDocument
  parseDOM(html) {
    return new DOMParser().parseFromString(html, 'text/html');
  },

  // Popular novels: tries /novels, otherwise home page posts
  async popularNovels(page = 1) {
    const base = await this.resolveBase();
    const urlCandidates = [
      `${base}/novels/page/${page}/`,
      `${base}/projects/page/${page}/`,
      `${base}/page/${page}/`,
      base,
    ];

    for (const url of urlCandidates) {
      try {
        const html = await this.fetchText(url);
        const doc = this.parseDOM(html);

        // Common patterns: article.post, .novel-card, .project
        const items = Array.from(doc.querySelectorAll('article, .novel, .novel-item, .post, .project, .project-item'));
        const novels = items.map((el) => {
          const a = el.querySelector('a[href]');
          const titleEl = el.querySelector('h2, h3, .title, .entry-title') || a;
          const title = titleEl ? titleEl.textContent.trim() : (a ? a.href : 'Unknown');
          const url = a ? new URL(a.getAttribute('href'), url).toString() : null;
          let cover = null;
          const img = el.querySelector('img');
          if (img) cover = new URL(img.getAttribute('src'), url).toString();
          return url ? { title, url, cover } : null;
        }).filter(Boolean);

        if (novels.length) return novels;
      } catch (e) {
        // try next candidate
      }
    }
    return [];
  },

  // Search using WordPress search or site search
  async searchNovels(query, page = 1) {
    const base = await this.resolveBase();
    // try common search endpoints
    const searchUrls = [
      `${base}/?s=${encodeURIComponent(query)}&post_type=post`,
      `${base}/?s=${encodeURIComponent(query)}`,
      `${base}/search/${encodeURIComponent(query)}/page/${page}/`,
      `${base}/?s=${encodeURIComponent(query)}&paged=${page}`,
    ];

    for (const url of searchUrls) {
      try {
        const html = await this.fetchText(url);
        const doc = this.parseDOM(html);
        const items = Array.from(doc.querySelectorAll('article, .result-item, .search-result, .novel-item, .post'));
        const results = items.map((el) => {
          const a = el.querySelector('a[href]');
          if (!a) return null;
          const titleEl = el.querySelector('h2, h3, .title, .entry-title') || a;
          const title = titleEl ? titleEl.textContent.trim() : a.textContent.trim();
          const url2 = new URL(a.getAttribute('href'), url).toString();
          const img = el.querySelector('img');
          const cover = img ? new URL(img.getAttribute('src'), url).toString() : null;
          return { title, url: url2, cover };
        }).filter(Boolean);
        if (results.length) return results;
      } catch (e) {
        // continue
      }
    }
    // fallback to empty
    return [];
  },

  // Get novel details and chapters list
  async getNovelDetails(novelUrl) {
    const html = await this.fetchText(novelUrl);
    const doc = this.parseDOM(html);

    // Title
    const titleEl = doc.querySelector('h1.entry-title, h1.post-title, h1, .novel-title') || doc.querySelector('title');
    const title = titleEl ? titleEl.textContent.trim() : '';

    // Cover
    let cover = null;
    const coverEl = doc.querySelector('.novel-cover img, .post-thumbnail img, .entry-content img, img');
    if (coverEl) cover = new URL(coverEl.getAttribute('src'), novelUrl).toString();

    // Description
    const descEl = doc.querySelector('.entry-content p, .summary, .novel-description, .post-content, .entry-content');
    const description = descEl ? descEl.textContent.trim() : '';

    // Authors / Genres (best-effort)
    const metaText = Array.from(doc.querySelectorAll('.meta, .novel-meta, .entry-meta, .book-meta')).map(el => el.textContent.trim()).join('\n');

    // Chapters: many WP novel pages have a link to a 'chapters' page, or the chapter list in the post content.
    // Try multiple selectors.
    let chapters = [];

    const chapterContainers = Array.from(doc.querySelectorAll('.chapters, .chapter-list, .wp-block-latest-posts, .entry-content ol, .entry-content ul, .post-content'));
    for (const cont of chapterContainers) {
      const anchors = Array.from(cont.querySelectorAll('a[href]'));
      for (const a of anchors) {
        const text = a.textContent.trim();
        const href = new URL(a.getAttribute('href'), novelUrl).toString();
        // Basic filter: skip links to other domains or to the novel itself
        if (!href || href === novelUrl) continue;
        chapters.push({ title: text || href, url: href });
      }
      if (chapters.length) break;
    }

    // Some sites keep chapters on a separate "episodes" page. Try to detect a link to that.
    if (!chapters.length) {
      const epsLink = doc.querySelector('a[href*="episode"], a[href*="chapter"], a[href*="chapters"], a[href*="episodes"], a[href*="story/"]');
      if (epsLink) {
        try {
          const epsUrl = new URL(epsLink.getAttribute('href'), novelUrl).toString();
          const epsHtml = await this.fetchText(epsUrl);
          const epsDoc = this.parseDOM(epsHtml);
          const anchors = Array.from(epsDoc.querySelectorAll('a[href]'));
          for (const a of anchors) {
            const text = a.textContent.trim();
            const href = new URL(a.getAttribute('href'), epsUrl).toString();
            if (!href || href === epsUrl) continue;
            // naive filter: include links that contain 'chapter' or 'episode' or have many digits
            if (/chapter|ch\b|episode|ep\b|chap/i.test(href) || /ch\d+|ep\d+/i.test(text)) {
              chapters.push({ title: text || href, url: href });
            }
          }
        } catch (e) {
          // ignore
        }
      }
    }

    // Deduplicate and normalize ordering (many sites list newest first)
    const seen = new Set();
    chapters = chapters.reverse ? chapters.reverse() : chapters;
    const dedup = [];
    for (const c of chapters) {
      if (seen.has(c.url)) continue;
      seen.add(c.url);
      dedup.push(c);
    }

    return {
      title,
      cover,
      description,
      meta: metaText,
      chapters: dedup,
    };
  },

  // Get chapter content (returns HTML string ready for LNReader)
  async getChapterContent(chapterUrl) {
    const html = await this.fetchText(chapterUrl);
    const doc = this.parseDOM(html);

    // Common chapter container selectors
    const selectors = [
      '.entry-content',
      '.chapter-content',
      '#chapter-content',
      '.post-content',
      '.content',
      '.read-content',
    ];

    let container = null;
    for (const s of selectors) {
      const el = doc.querySelector(s);
      if (el && el.textContent.trim()) {
        container = el;
        break;
      }
    }

    if (!container) {
      // fallback: use body
      container = doc.body;
    }

    // Clean up: remove scripts, ads, '.share' elements, navs
    const removeSelectors = ['script', 'noscript', 'style', '.ads', '.share', '.wp-block-button', '.nav-links', '.toc', '.pagination', '.related'];
    for (const rs of removeSelectors) {
      doc.querySelectorAll(rs).forEach(n => n.remove());
    }

    // Return innerHTML of container
    return container.innerHTML.trim();
  },

  // Optional: latest updates
  async latestNovels(page = 1) {
    const base = await this.resolveBase();
    const urls = [
      `${base}/feed/`,
      `${base}/?s=&post_type=post&page=${page}`,
      `${base}/page/${page}/`,
    ];
    for (const url of urls) {
      try {
        const html = await this.fetchText(url);
        const doc = this.parseDOM(html);
        const items = Array.from(doc.querySelectorAll('article, .post, .entry'));
        const results = items.map((el) => {
          const a = el.querySelector('a[href]');
          if (!a) return null;
          const titleEl = el.querySelector('h2, h3, .title') || a;
          const title = titleEl ? titleEl.textContent.trim() : a.textContent.trim();
          const url2 = new URL(a.getAttribute('href'), url).toString();
          const img = el.querySelector('img');
          const cover = img ? new URL(img.getAttribute('src'), url).toString() : null;
          return { title, url: url2, cover };
        }).filter(Boolean);
        if (results.length) return results;
      } catch (e) {
        // continue
      }
    }
    return [];
  },
};

export default PLUGIN;

